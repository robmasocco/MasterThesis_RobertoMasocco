% Chapter 2
% Roberto Masocco <robmasocco@gmail.com>
% August 28, 2021

\chapter[Nuovi problemi e nuove soluzioni]{Nuovi problemi e nuove soluzioni}
\label{Chapter2}
\doublespacing
\fontsize{14}{14}\selectfont

\phantomsection
\section*{Premessa}
\sectionmark{Premessa}
\addcontentsline{toc}{section}{Premessa}
\indent Lo sviluppo di un sistema robotico autonomo è un processo che attraversa varie fasi. Ciascuna di esse è solitamente caratterizzata dalla definizione e soluzione di problematiche inerenti diversi aspetti dell'apparato, che possono andare dalle operazioni che questo sarà chiamato a svolgere, alla sua costruzione e programmazione, fino al modo in cui i dati che esso raccoglie e che condizionano il suo funzionamento debbano essere presentati agli eventuali operatori. Volendo generalizzare dallo specifico caso applicativo, la maggior parte delle problematiche si possono ripartire tra poche tipologie di alto livello. Nonostante possa risultare controintuitivo dalla suddivisione che ci si appresta a delineare, queste non sempre si rivelano affrontabili in sequenza, né tanto meno completamente indipendenti. È anche per risolvere situazioni simili che negli ultimi tempi sono state ideate svariate tecniche di project management, volte anche a minimizzare il rischio che un errore commesso in una fase precedente possa pregiudicare quelle future, compromettendo il lavoro svolto ed allungando i tempi di sviluppo. In virtù di quanto osservato nel capitolo precedente, è chiaro che con l'aumentare della complessità dei sistemi automatici odierni e dei compiti che essi devono svolgere, queste tematiche siano quanto mai attuali. In particolare, nuovi strumenti messi a disposizione di sviluppatori e progettisti dovranno riflettere queste specificità, semplificare la gestione di situazioni tipiche dove possibile, ed evidenziare eventuali criticità per aiutare nella soluzione dei problemi. Nonostante la generalizzazione che si sta facendo possa sembrare eccessiva, nella realtà pratica si riscontra facilmente che a dispetto della varietà di casi di specie e applicazioni, le complicazioni da affrontare sono quasi sempre se non le stesse, molto simili, e lo stesso si può rilevare circa le strategie da adottare. L'obiettivo di questo capitolo è presentare brevemente le problematiche che solitamente si devono affrontare quando si progetta un sistema robotico, evidenziandone le peculiarità seppur senza concentrarsi su un particolare ambito applicativo, e passare poi ad esaminare alcune recenti soluzioni hardware e software che consentono di ottimizzare il lavoro di progettazione, sviluppo e testing in loro funzione. La discussione parte ora da un livello abbastanza alto di astrazione ma diventerà via via sempre più specifica, costituendo di fatto la linea guida seguita durante il progetto che costituisce il caso di studio di questo lavoro e dunque un filo che lega tutti i capitoli successivi.

\phantomsection
\section*{Fasi progettuali}
\sectionmark{Fasi progettuali}
\addcontentsline{toc}{section}{Fasi progettuali}
\phantomsection
\subsection*{I task}
\addcontentsline{toc}{subsection}{I task}
\indent Le prime decisioni da prendere all'inizio del progetto di un sistema automatico o robotico riguardano naturalmente le specifiche delle operazioni che questo dovrà svolgere. Esse vanno completamente delineate fin da subito nei minimi particolari, in quanto è da loro che dipenderanno tutte le scelte successive, da quelle inerenti la costruzione e la scelta dell'hardware fino alla sua programmazione. Durante questa decomposizione dei requisiti operativi in \emph{task}, intesi come singole unità di lavoro da eseguire, compariranno diversi tipi di questi ultimi. Senza per ora scendere nei particolari di uno specifico caso, tipologie comuni sono:
\begin{itemize}
    \item task \textbf{continuativi}, ossia iniziati all'accensione del sistema e mai interrotti;
    \item task \textbf{periodici}, da eseguire a intervalli regolari;
    \item task \textbf{asincroni}, svolti solo quando un particolare evento si verifica.
\end{itemize}
È facile rendersi conto di come gran parte delle funzionalità presenti nei sistemi robotici odierni possa essere decomposta in task appartenenti a ciascuna di queste categorie. Ne fanno evidentemente parte operazioni che vanno dal controllo degli attuatori, alla raccolta di dati e misure necessari agli algoritmi di controllo, fino alla comunicazione con operatori ed utenti. Le specificità di questi task avranno risvolti sia sull'hardware che dovrà realizzarli che sul software che li codificherà, i quali dovranno essere organizzati opportunamente in loro funzione, anche in modo da facilitarne lo sviluppo e la manutenzione.

\phantomsection
\subsection*{L'hardware}
\addcontentsline{toc}{subsection}{L'hardware}
\indent Le decisioni da prendere successivamente riguardano l'hardware da utilizzare per realizzare i primi prototipi dell'apparato. Probabilmente non si tratterà di quello che comporrà il prodotto finito, per via di eventuali errori di valutazione, imprevisti o altre problematiche sorte successivamente. Ciò nonostante esso deve essere selezionato con cura in base ai requisiti operativi, strutturali e costruttivi definiti fin qui. Le decisioni prese durante il passo precedente rivestono in questa fase un'importanza cruciale: stabilendo infatti quale sia la complessità computazionale delle operazioni che il sistema dovrà svolgere, sarà richiesto un hardware di alto livello più o meno potente, equipaggiato eventualmente con coprocessori discreti\footnote{Con il termine \emph{discreto} si intende hardware aggiuntivo montato su di un calcolatore, non in grado di operare da solo ma fatto per essere pilotato da quest'ultimo, offrendogli supporto specifico per particolari operazioni; classici esempi sono i coprocessori matematici, le GPU e le schede audio.} necessari per trattare particolari tipi di dati, o suddiviso in più sottosistemi interconnessi. Al giorno d'oggi, ricordando la dicussione fatta nel capitolo precedente circa la disponibilità di un'ampia gamma di soluzioni off-the-shelf, è d'obbligo un'indagine di ciò che offre il mercato per capire se sia possibile sfruttare componenti o SoC forniti già testati e pronti per essere utilizzati, piuttosto che ricorrere ad una soluzione proprietaria che porta generalmente con sé considerevoli costi di sviluppo, testing e validazione. Per i motivi sopracitati è molto difficile, se non impossibile, delineare fin da questo punto una struttura complessiva e definitiva dell'hardware: ciò che importa è capire di cosa c'è bisogno e se esistono sul mercato offerte compatibili con i propri requisiti, cercando di prevedere anche successive richieste aggiuntive. Seguendo questa linea, eventuali variazioni potranno essere gestite similmente in seguito con poco sforzo. Il resto delle scelte riguardano l'hardware di più basso livello, formato in generale da:
\begin{itemize}
    \item microcontrollori veloci;
    \item attuatori;
    \item sensori;
    \item interfacce e dispositivi di comunicazione;
    \item hardware per il controllo e la supervisione;
    \item sistemi di immagazzinamento di dati.
\end{itemize}
Niente di più si può dire su di esse prescindendo dal caso di specie, tuttavia nel seguito di questo lavoro saranno descritte situazioni simili relative all'esempio che si discuterà. Per ora ci si può limitare a sottolineare che le osservazioni fatte precedentemente valgono anche per questi componenti.

\phantomsection
\subsection*{Il software}
\addcontentsline{toc}{subsection}{Il software}
\indent Eccezion fatta per quei componenti che svolgono funzioni cruciali e molto specifiche, come circuiti elettrici/elettronici, la quasi totalità delle operazioni svolte da un sistema robotico è oggi codificata in un calcolatore ad esso interno, che traduce tali istruzioni in comandi per gli altri componenti, sottosistemi, sensori o attuatori. Non è questa la sede per la dicussione di procedure standard di progettazione e realizzazione del software, ma basta soffermarsi a riflettere su un punto: anche il software che governa un robot, data la complessità di quest'ultimo, avrà un'organizzazione stratificata e fortemente gerarchica. In essa, i livelli inferiori saranno occupati da quei moduli che dovranno interagire con, se non muovere, i sottosistemi più piccoli e veloci (e.g. il \emph{firmware}), e che andranno sviluppati ponendo particolare attenzione alle caratteristiche di essi ed alle loro finalità. Man mano che si sale nella scala gerarchica ci si muove verso moduli a più ampio spettro, che codificano operazioni di supervisione, pianificazione e comunicazione con gli utenti, e per questo più vicini alla nozione di software applicativo o di sistema, con cui magari si è più abituati ad avere a che fare essendo quello maggiormente "visibile" ad un utente finale. Supponendo di dover operare in questo contesto, si deve poter contare su degli strumenti che semplifichino il più possibile il design e lo sviluppo a tutti i livelli senza distinzione, aiutando nella gestione di problematiche inerenti l'organizzazione dei moduli, la comunicazione, il processamento e la memorizzazione di diversi tipi di dati. Rientra in questo contesto anche una decisione circa i linguaggi di programmazione da adottare. Com'è noto, ciascuno possiede le sue caratteristiche peculiari, che ne evidenziano rispetto alle alternative punti di forza ma anche debolezze. Pochi sono i linguaggi di programmazione adatti per molteplici scopi, intendendo in questo senso il grado di facilità con cui consentono di codificare diversi tipi di task, e nessuno è da considerarsi universale. Nel seguito di questo lavoro verranno presentate, a titolo di esempio, due diverse alternative, mettendone in risalto le specificità e motivando un uso preponderante di una delle due con dei requisiti progettuali del caso di studio.

\phantomsection
\subsection*{I dati e le misure}
\addcontentsline{toc}{subsection}{I dati e le misure}
\indent Un robot, per portare a termine i propri task con successo, necessita più o meno costantemente di informazioni circa quello che gli sta accadendo intorno. Esse possono essere ricevute entro pacchetti dati, gestiti da opportune interfacce di comunicazione, oppure acquisite direttamente mediante degli organi di misurazione, comunemente detti \emph{sensori}. Per entrambe queste soluzioni, problematiche classiche che si incontrano da subito sono l'integrazione dei relativi dispositivi nel resto dell'apparato e il processamento dei dati che queste restituiscono. Esse sono peraltro cruciali, in quanto il funzionamento dell'intero apparato è quasi sempre condizionato alla possibilità di disporre di informazioni circa l'ambiente circostante e lo stato del robot stesso\footnote{Si pensi agli algoritmi di controllo in \emph{feedback}, basati sulla possibilità di acquisire misure delle azioni di controllo impartite ad un sistema e di grandezze che ne esplicitano gli effetti.}. E' dunque lecito aspettarsi che un robot sia dotato di una gran quantità di interfacce di comunicazione e sensori, questi ultimi composti da hardware specifico atto a misurare particolari grandezze fisiche d'interesse. Le due problematiche introdotte poco fa riguardano pertanto l'integrazione di tale hardware con il resto del sistema e la scrittura di moduli software capaci di gestirlo e processare i dati che produce. Sia le piattaforme hardware che gli strumenti software dovrebbero essere sviluppati o scelti, per quanto possibile, tenendo conto di queste eventualità in modo da minimizzarne l'impatto e facilitare il lavoro.

\phantomsection
\subsection*{Debugging, testing e deployment}
\addcontentsline{toc}{subsection}{Debugging, testing e deployment}
\indent Non appena i primi prototipi vengono finalizzati occorre iniziare a testarli per verificarne il funzionamento e confermare la validità delle decisioni progettuali prese fino a quel punto. Tenendo presente che non si può definire una procedura di testing generica e universale per qualunque tipo di sistema robotico, ci si può aspettare che non appena si è constatato il corretto funzionamento dell'hardware, si debba passare alla validazione del software. Il debugging del software in esecuzione su un robot è in generale più difficile rispetto a quello di un comune software applicativo, e ciò a causa di diverse specificità:
\begin{itemize}
    \item E' più difficile tracciare l'esecuzione di programmi su un dispositivo autonomo, potenzialmente in movimento: non è detto che si abbia accesso diretto al sistema e tipicamente gli strumenti a disposizione non sono molto sofisticati.
    \item In caso di problemi, oltre al software va ricontrollato anche l'hardware in uso, in quanto il problema potrebbe anche essere casuato da quest'ultimo o da un suo uso non corretto.
    \item Eseguire test non è semplice quanto lanciare un programma e controllarne gli esiti: va assicurata anche la sicurezza dell'apparato e dei suoi operatori durante l'intera procedura, motivo per cui già la sola organizzazione di un test può risultare impegnativa.
\end{itemize}
Date la difficoltà e l'importanza di questa fase, è ragionevole voler impiegare strumenti e metodologie che possibilmente facilitino le cose anche a questo livello. Infine si può passare al \emph{deployment}, ossia la costruzione di un apparato che si possa considerare un prodotto finito da mettere in uso. E' questo il momento in cui si manifestano le conseguenze di alcune scelte progettuali che in questa sede si è scelto di non trattare, relative ad esempio alla produzione e realizzazione delle varie parti. Ciò non toglie come una ragionevole oculatezza nelle fasi precedenti possa risultare conveniente anche qui.

\phantomsection
\indent Alla luce della discussione appena conclusa, si rileva come le problematiche da affrontare nella realizzazione di un sistema robotico siano molteplici e variegate, come pure le scelte che si è chiamati a fare in diversi punti dello sviluppo. Le ripercussioni che queste possono avere sono pure diversificate, e rischiano di manifestarsi anche a stadi più avanzati. In tempi recenti le difficoltà delineate si sono poi acuite, proprio a causa della maggiore complessità ed autonomia demandate a tali apparati. Ciò nonostante lo sviluppo tecnologico è proseguito, rendendo anche piccoli SoC dotati di CPU multicore performanti, RAM capiente e GPU, e capaci di integrarsi facilmente con microcontrollori numerici più veloci e sottosistemi real-time più piccoli, eseguendo task abbastanza veloci oppure più lenti, ad esempio di supervisione, coordinamento o comunicazione. Quello che resta sono le difficoltà relative alla programmazione e lo sviluppo del software dedicato. Il resto di questo capitolo è dedicato alla discussione di nuove soluzioni, recentemente divenute interessanti in ambiti quali IoT, mobile devices e telecomunicazioni, ma che stanno trovando anche in quello in esame enormi risvolti applicativi. E' anche grazie ad esse che il drone autonomo descritto successivamente, esempio pratico di questo studio, è stato realizzato con relativa semplicità.
