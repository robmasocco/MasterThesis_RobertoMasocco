% Chapter 1
% Roberto Masocco <robmasocco@gmail.com>
% August 15, 2021

\chapter[Introduzione]{Introduzione}
\label{chap:Chapter1}
\doublespacing
\fontsize{14}{14}\selectfont

\indent Pervasività. Una parola che, come quasi il suo significato suggerisce, si sta facendo pian piano largo nelle cronache della quotidianità, per descrivere efficacemente l'impatto che le nuove tecnologie stanno avendo sulla vita di tutti i giorni. È immediato constatare quanti siano oggi i compiti e le sfide per affrontare le quali ci affidiamo, in tutto o in parte, alle macchine. Si tratta di un numero crescente e destinato a rimanere tale, e mentre aumentano le mansioni che possiamo svolgere con l'aiuto di dispositivi automatici, allo stesso modo compaiono nuovi scenari e possibilità che questi ci offrono. Ricerca, medicina, logistica, svago: sono solo alcuni degli innumerevoli ambiti in cui l'introduzione di dispositivi robotici e autonomi, via via sempre più sofisticati, ha portato negli ultimi decenni a delle innovazioni con un ritmo senza precedenti. Questa diffusione sempre più capillare porta però con sé un incremento della loro complessità, sia di progettazione che di realizzazione, cosa di cui spesso ci si fregia ma che più sommessamente si riconosce come fonte di nuove sfide e difficoltà. Ciò è, prima di tutto, per via della moltitudine dei compiti che questi apparati sono oggi chiamati a svolgere e della loro varietà.\\
Una seconda causa delle crescenti difficoltà con cui progettisti e sviluppatori devono misurarsi viene dai dati necessari per operare. Conseguenza dell'enorme diffusione delle nuove tecnologie è anche una capacità senza pari nella storia moderna di raccogliere informazioni sul mondo che ci circonda e sulle persone che lo abitano. Questa mole di dati, varia e diversificata, costituisce l'input degli algoritmi di Intelligenza Artificiale che sono oggi alla base di sempre più sistemi di calcolo e automazione. La loro validità piuttosto generale e la possibilità di raccogliere virtualmente ogni genere di informazione necessaria per il loro funzionamento sono solo due delle ragioni per cui essi stanno prendendo piede in moltissimi ambiti della vita contemporanea. Ciò nonostante, tali \emph{big data} sono complicatissimi da gestire. Progettare un sistema in grado di processare questo genere di input e operare di conseguenza porta chiaramente a confrontarsi con nuovi problemi e richiede strumenti innovativi.\newpage
Acquisire tutte queste informazioni richiede inoltre un'infrastruttura di comunicazione robusta, efficiente e di grande portata. Se da un lato la rete Internet ha recentemente permesso di trasmettere dati senza fatica e a velocità elevatissime, dall'altro ogni dispositivo che la utilizza deve poterlo fare nel modo migliore per i suoi scopi. Questo implica che sia l'hardware che realizza la comunicazione, sia i protocolli che la regolano, devono essere adeguati e supportare funzionalità appropriate. Tipici esempi di situazioni in cui è necessaria una connessione tra dispositivi vanno dalla ricezione di comandi remoti all'aggiornamento del software in esecuzione sugli stessi, quest'ultimo uno scenario critico che va gestito con la massima cura per non rischiare di pregiudicare l'operatività o causare danni.\\
È poi sempre più attraverso la Rete che si realizza l'interfacciamento tra tali apparati ed i loro operatori umani, per finalità che vanno dalla supervisione al vero e proprio controllo, senza più alcuna restrizione alla distanza tra i luoghi in cui essi sono fisicamente posti. Considerati tutti i fattori elencati fino a questo punto, ci si deve aspettare che anche le interazioni con l'uomo siano destinate ad aumentare e diventare parte sempre maggiore delle mansioni di questi sistemi.\\
Per raccogliere queste nuove sfide e far sì che la comunità di progettisti e sviluppatori riesca a soddisfare le necessità dell'industria e del mercato, occorre riflettere su cosa si ha già a disposizione e quali novità è invece necessario integrare. In primo luogo, un sistema autonomo moderno ha bisogno di una potenza di calcolo adeguata ad acquisire misure, ricevere informazioni, processare dati ed azionare attuatori, il tutto in tempo reale. Questo requisito va naturalmente di pari passo con la complessità del sistema e dei task per cui esso è programmato, sulla base di quanto già discusso. Si può osservare negli ultimi dieci anni come l'industria si stia già muovendo in tal senso: dacché la maggior parte dei sistemi robotici e automatici erano mossi da semplici microcontrollori numerici, demandando operazioni di gestione ad apparati di supervisione o agli operatori umani, oggi non è raro trovare pressappoco ovunque sistemi piccoli ma performanti, altamente integrati, in grado di svolgere operazioni sia di alto che di basso livello e di interfacciarsi con altri componenti più o meno complessi.\newpage
È ormai comune lo scenario in cui un unico sistema è controllato da un'elettronica di bordo composta da più SoC diversi e interconnessi che si dividono i compiti a vari livelli: dal microcontrollore veloce che acquisisce le misure dai sensori e aziona gli attuatori, al computer di bordo che comunica con l'esterno e applica onerosi algoritmi per decidere di volta in volta cosa fare e come reagire agli stimoli. L'efficacia di queste soluzioni è innegabile, tanto che ha portato all'esplosione di un mercato rimasto per molto tempo di nicchia, ossia quello dei microcomputer, microcontrollori, SoC e sistemi embedded, che al giorno d'oggi sono venduti a prezzi competitivi anche al di fuori dell'ambito industriale ed utilizzati da hobbisti e amatori (e.g. i \emph{maker}) per la realizzazione di piccoli progetti "fai-da-te". La disponibilità di una varietà così ampia di sistemi digitali ha poi reso la sperimentazione in ambito accademico molto più semplice, consentendo di dare forma rapidamente e con poco sforzo a nuove idee.\\
Progettando un nuovo apparato, scegliere l'hardware che lo comporrà può risultare comunque complicato. Riguardo la sola elettronica di bordo ad esempio, nonostante la gamma di componenti disponibili \emph{off-the-shelf} sia più che mai ampia resta sempre il doveroso confronto di ogni soluzione preesistente con una sviluppata ad hoc, che ci si può aspettare risulti meglio ottimizzata ma in generale più costosa. In ogni caso, sempre per far fronte alle nuove criticità, usare l'hardware deve essere semplice e la ragione di ciò è palese: se il futuro sarà popolato da un gran numero di dispositivi tutti in grado di comunicare, interagire, cooperare tra loro e con l'uomo per risolvere problemi complicati, il software che li muove dovrà essere comparabilmente sofisticato, efficiente, sicuro e mantenibile. Gli strumenti coi quali è possibile scrivere agevolmente software con queste caratteristiche dovranno semplificare problematiche classiche e consentire di definire intuitivamente la struttura del lavoro. Ciò consentirebbe infatti di concentrarsi sui nuovi problemi, incrementando la qualità dei prodotti sviluppati ed evitando di perdere tempo a riflettere su come risolvere in modi diversi questioni già affrontate, concetto questo riassunto dal celebre adagio "non reinventare la ruota".\newpage
Considerando infine anche l'evoluzione del mondo dello sviluppo del software, sempre più comunitario e aperto al contributo del pubblico, è naturale ritenere che le nuove soluzioni debbano essere, salvo casi specifici, \emph{libere} ed \emph{open-source}. Ciò consentirebbe di velocizzare il progresso sotto ogni punto di vista poiché, se si hanno a disposizione pacchetti di codice pronto da riutilizzare o modificare per meglio adattarlo al proprio caso d'uso, ci si può dedicare a scrivere quello che ancora non esiste poggiando sempre su basi solide e collaudate. Inoltre condividere il software su cui si lavora ha molti altri vantaggi, tra cui un'attiva collaborazione ai fini del \emph{testing} e del \emph{debugging} ed una gestione collegiale delle problematiche di sicurezza, alla quale può partecipare l'intera comunità scientifica: sono infatti svariati i casi\footnote{Si veda ad esempio quanto accaduto con gli algoritmi di autenticazione COMP128 per reti GSM (2G) tra il 1997 ed il 1998.} di tecnologie proprietarie mantenute intenzionalmente sconosciute al pubblico contando sulla \emph{security-by-obscurity}, rivelatesi poi affette da gravi problemi che la collettività degli addetti ai lavori ha scoperto ed evidenziato mediante \emph{reverse engineering}. Anche questo è un punto che l'industria ha riconosciuto abbastanza recentemente come fondamentale per favorire l'innovazione: basti pensare alla fioritura e diffusione nell'ultimo decennio di servizi di hosting di repository remoti basati su sistemi di controllo versione e che integrano funzionalità di discussione, revisione e condivisione, nei quali molto del software su cui poggiano i servizi ormai d'uso comune è mantenuto e sviluppato.\\
Appare chiaro dunque come la progettazione e realizzazione di apparati robotici debba avvalersi di nuovi strumenti e metodologie multilivello, per realizzare un ulteriore avanzamento e rispondere alle necessità presenti e future. L'obiettivo di questo lavoro è presentare una breve panoramica delle più recenti soluzioni ai problemi elencati, disponibili nell'ambito della robotica e che soddisfano i requisiti descritti, corredata da prove sperimentali della loro applicabilità ed efficacia. Come caso di studio si presenta un drone autonomo per volo automatico, la cui progettazione e realizzazione verranno descritte nel seguito, sviluppato nell'ambito dell'edizione 2021 del Leonardo Drone Contest e testato presso la Divisione Velivoli di Leonardo S.p.A. a Torino, Italia.\newpage
Il resto di questo documento è organizzato come segue: nel Capitolo \ref{chap:Chapter2} verranno discussi i più recenti strumenti software rivolti alla realizzazione di sistemi autonomi complessi e distribuiti; nel Capitolo \ref{chap:Chapter3} verrà introdotto il caso di studio del drone, discutendone le componenti hardware, il software ed i risultati ottenuti; nel Capitolo \ref{chap:Chapter4} verrà presentata l'implementazione di un controllore in retroazione su tale architettura; infine nel Capitolo \ref{chap:Chapter5} verranno riassunte le novità presentate e proposti alcuni sviluppi successivi.
